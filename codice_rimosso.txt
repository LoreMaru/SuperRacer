//backup
    originale:
    //Funzione che permette ai nemici di avvicinarsi al giocatore
    this.enemies.getChildren().forEach(enemy => {
      //Protezione: verifica che l'enemy sia ancora attivo
      if (!enemy.active) return;
    
      //Protezione: aggiorna animazione solo se esiste
      if (enemy.powerAnimation && enemy.powerAnimation.active) {
        enemy.powerAnimation.x = enemy.x;
        enemy.powerAnimation.y = enemy.y;
      }
    
      //Calcola distanza dal giocatore
      const distance = Phaser.Math.Distance.Between(enemy.x, enemy.y, this.car.x, this.car.y);
    
      if (enemy.isTracking) {
        //smette di inseguire in base alla distanza o se troppo in basso
        if (distance <= 50 || enemy.y > 500) {
          enemy.isTracking = false;
          enemy.body.setVelocity(0, 100); // scende solo in verticale

          this.lifeBar.height -= 10;

          enemy.powerAnimation.play(enemy.keyAnimazione)
          .setVisible(true)
          .setOrigin(0.5)
          .setDepth(2)
          .setScale(1.2)
          .setAlpha(0.7);
        } else {
          this.physics.moveToObject(enemy, this.car, 100);
        }
      }
    
      //Pulisci nemico e animazione se esce dallo schermo
      if (enemy.y > 700) {
        if (enemy.powerAnimation && enemy.powerAnimation.active) {
          enemy.powerAnimation.destroy();
        }
        enemy.destroy();
      }
    });
    -----

    "nuovo"
    this.enemies.getChildren().forEach(enemy => {
  if (!enemy.active) return;

  const dist = Phaser.Math.Distance.Between(enemy.x, enemy.y, this.car.x, this.car.y);
  const playerPowered = this.powerBar.height > 0;

  switch (enemy.state) {
    case 'IDLE':
      if (!playerPowered) {
        enemy.state = 'CHASING';
      }
      break;

    case 'CHASING':
      if (playerPowered) {
        enemy.state = 'AVOIDING';
      } else if (dist < 30) {
        enemy.state = 'ATTACKING';
        enemy.body.setVelocity(0);
        scene.time.delayedCall(500, () => {
          enemy.attackReady = true;
        });
      } else {
        this.physics.moveToObject(enemy, this.car, 100);
      }
      break;

    case 'AVOIDING':
      if (!playerPowered) {
        enemy.state = 'CHASING';
      } else {
        enemy.body.setVelocityX(enemy.x < this.car.x ? -100 : 100);
        enemy.body.setVelocityY(20);
      }
      break;

    case 'ATTACKING':
      // Ferma nemico e attesa, il collider lo sposterà su DONE
      enemy.body.setVelocity(0);
      break;

    case 'DONE':
      enemy.body.setVelocity(0, 100);
      // Rimuovi se esce dallo schermo
      if (enemy.y > 700) enemy.destroy();
      break;
  }
});
---
    
    
    
    
    //Funzione che permette ai nemici di avvicinarsi al giocatore
    this.enemies.getChildren().forEach(enemy => {
      //Protezione: verifica che l'enemy sia ancora attivo
      if (!enemy.active) return;
    
      //Protezione: aggiorna animazione solo se esiste
      if (enemy.powerAnimation && enemy.powerAnimation.active) {
        enemy.powerAnimation.x = enemy.x;
        enemy.powerAnimation.y = enemy.y;
      }
    
      //Calcola distanza dal giocatore
      const distance = Phaser.Math.Distance.Between(enemy.x, enemy.y, this.car.x, this.car.y);
    
      if (enemy.isTracking) {
        //smette di inseguire in base alla distanza o se troppo in basso
        if (distance <= 50 || enemy.y > 500) {
          enemy.isTracking = false;
          enemy.body.setVelocity(0, 100); // scende solo in verticale

          this.lifeBar.height -= 10;

          enemy.powerAnimation.play(enemy.keyAnimazione)
          .setVisible(true)
          .setOrigin(0.5)
          .setDepth(2)
          .setScale(1.2)
          .setAlpha(0.7);
        } else {
          this.physics.moveToObject(enemy, this.car, 100);
        }
      }
    
      //Pulisci nemico e animazione se esce dallo schermo
      if (enemy.y > 700) {
        if (enemy.powerAnimation && enemy.powerAnimation.active) {
          enemy.powerAnimation.destroy();
        }
        enemy.destroy();
      }
    });



//il pezzo sull'animazione bisogna rimetterlo

    this.enemies.getChildren().forEach(enemy => {
      const distance = Phaser.Math.Distance.Between(enemy.x, enemy.y, this.car.x, this.car.y);
      enemy.powerAnimation.x = enemy.x;
      enemy.powerAnimation.y = enemy.y;

      if (enemy.isTracking) {
        if (distance > 50) {
      // Ancora lontano: continua a inseguire il giocatore
          this.physics.moveToObject(enemy, this.car, 100);
        }else{
        // È vicino: smette di inseguire e va dritto giù
          enemy.isTracking = false;
        }

        /*if(distance < 40){
          //this.lifeBar.height -= 15;
          enemy.body.setVelocity(0, 100); // Solo verso il basso
          enemy.powerAnimation.play(enemy.keyAnimazione)
          .setVisible(true)
          .setOrigin(0.5)
          .setDepth(2)
          .setScale(1.2)
          .setAlpha(0.7);
        }*/
      }
  // Se è sceso fuori dallo schermo, lo eliminiamo
      if (enemy.y > 700) {
        enemy.destroy();
      }
    });





//non funziona
export function spawnRandomObject(scene, car) {
  let objectToSpawn;
  let randomItem = Phaser.Math.Between(1, 10);
  isEven(randomItem) ? objectToSpawn = 'power' : objectToSpawn = 'life';
  console.log(objectToSpawn)
  let obj = scene.physics.add.image(400, -100, `${objectToSpawn}`); // posizione iniziale fuori dallo schermo
  obj.setVelocityY(100); // scende lentamente verso il basso
  obj.setDepth(1); // sopra la pista

  scene.physics.add.overlap(car, obj, collectObject, null, this);
};

export function collectObject (obj){
    obj.disableBody(true, true);    
  }

export function spawnObjectsOverTime(scene, objSpawnDelay, minimumOBJSpawnDelay, car) {
  // genera il nemico
  spawnRandomObject(scene, car);
  // calcola il nuovo ritardo: ogni volta diminuisce del 10%
  objSpawnDelay *= 0.9;
  // limite minimo per non esagerare
  if (objSpawnDelay < minimumOBJSpawnDelay) {
    objSpawnDelay = minimumOBJSpawnDelay;
  }

  // richiama sé stessa dopo il nuovo delay
  scene.time.delayedCall(objSpawnDelay, () => {
    spawnObjectsOverTime(scene, objSpawnDelay, minimumOBJSpawnDelay);
  });
}